{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "Copied from hcipy\n",
    "\"\"\"\n",
    "\n",
    "\n",
    "\n",
    "def imshow_fieldv2(field, grid=None, ax=None, vmin=None, vmax=None, aspect='equal', norm=None, interpolation=None, non_linear_axes=False, cmap=None, mask=None, mask_color='k', *args, **kwargs):\n",
    "\t'''Display a two-dimensional image on a matplotlib figure.\n",
    "\tThis function serves as an easy replacement for the matplotlib.pyplot.imshow() function.\n",
    "\tIts signature mostly folows that of matplotlib, with a few minor differences.\n",
    "\tParameters\n",
    "\t----------\n",
    "\tfield : Field or ndarray\n",
    "\t\tThe field that we want to display. If this is an ndarray,\n",
    "\t\tthen the parameter `grid` needs to be supplied. If the field\n",
    "\t\tis complex, then it will be automatically fed into :func:`complex_field_to_rgb`.\n",
    "\t\tIf the field is a vector field with length 3 or 4, these will be \n",
    "\t\tinterpreted as an RGB or RGBA field.\n",
    "\tgrid : Grid or None\n",
    "\t\tIf a grid is supplied, it will be used instead of the grid of `field`.\n",
    "\tax : matplotlib axes\n",
    "\t\tThe axes which to draw on. If it is not given, the current axes will be used.\n",
    "\tvmin : scalar\n",
    "\t\tThe minimum value on the colorbar. If it is not given, then the minimum value \n",
    "\t\tof the field will be used.\n",
    "\tvmax : scalar\n",
    "\t\tThe maximum value on the colorbar. If it is not given, then the maximum value \n",
    "\t\tof the field will be used.\n",
    "\taspect : ['auto', 'equal', scalar]\n",
    "\t\tIf 'auto', changes the image aspect ratio to match that of the axes.\n",
    "\t\tIf 'equal', changes the axes aspect ratio to match that of the image.\n",
    "\tnorm : Normalize\n",
    "\t\tA Normalize instance is used to scale the input to the (0, 1) range for\n",
    "\t\tinput to the `cmap`. If it is not given, a linear scale will be used.\n",
    "\tinterpolation : string\n",
    "\t\tThe interpolation method used. The default is 'nearest'. Supported values\n",
    "\t\tare {'nearest', 'bilinear'}.\n",
    "\tnon_linear_axes : boolean\n",
    "\t\tIf axes are scaled in a non-linear way, for example on a log plot, then imshow_fieldv2\n",
    "\t\tneeds to use a more expensive implementation. This parameter is to indicate that this\n",
    "\t\talgorithm needs to be used.\n",
    "\tcmap : Colormap\n",
    "\t\tThe colormap with which to plot the image. It is ignored if a complex\n",
    "\t\tfield or a vector field is supplied.\n",
    "\tmask : field or ndarray\n",
    "\t\tIf part of the image needs to be masked, this mask is overlayed on top of the image.\n",
    "\t\tThis is for example useful when plotting a phase pattern on a certain aperture, which\n",
    "\t\thas no meaning outside of the aperture. Masks can be partially translucent, and will\n",
    "\t\tbe automatically scaled between (0, 1). Zero means invisible, one means visible.\n",
    "\tmask_color : Color\n",
    "\t\tThe color of the mask, if it is used.\n",
    "\t\n",
    "\tReturns\n",
    "\t-------\n",
    "\tAxesImage\n",
    "\t\tThe produced image.\n",
    "\t'''\n",
    "\timport matplotlib as mpl\n",
    "\timport matplotlib.pyplot as plt\n",
    "\tfrom matplotlib.image import NonUniformImage\n",
    "    import hcipy as hci\n",
    "\n",
    "\tif ax is None:\n",
    "\t\tax = plt.gca()\n",
    "\t\n",
    "\tax.set_aspect(aspect)\n",
    "\n",
    "\tif grid is None:\n",
    "\t\tgrid = field.grid\n",
    "\telse:\n",
    "\t\tfield = hci.Field(field, grid)\n",
    "\n",
    "\t# If field is complex, draw complex\n",
    "\tif np.iscomplexobj(field):\n",
    "\t\tf = complex_field_to_rgb(field, rmin=vmin, rmax=vmax, norm=norm)\n",
    "\t\tvmin = None\n",
    "\t\tvmax = None\n",
    "\t\tnorm = None\n",
    "\telse:\n",
    "\t\tf = field\n",
    "\t\n",
    "\t# Automatically determine vmin, vmax, norm if not overridden\n",
    "\tif norm is None and not np.iscomplexobj(field):\n",
    "\t\tif vmin is None:\n",
    "\t\t\tvmin = np.nanmin(f)\n",
    "\t\tif vmax is None:\n",
    "\t\t\tvmax = np.nanmax(f)\n",
    "\t\tnorm = mpl.colors.Normalize(vmin, vmax)\n",
    "\t\n",
    "\t# Get extent\n",
    "\tc_grid = grid.as_('cartesian')\n",
    "\tmin_x, min_y, max_x, max_y = c_grid.x.min(), c_grid.y.min(), c_grid.x.max(), c_grid.y.max()\n",
    "\n",
    "\tif grid.is_separated and grid.is_('cartesian'):\n",
    "\t\t# We can draw this directly\n",
    "\t\tx, y = grid.coords.separated_coords\n",
    "\t\tz = f.shaped\n",
    "\t\tif np.iscomplexobj(field) or field.tensor_order > 0:\n",
    "\t\t\tz = np.rollaxis(z, 0, z.ndim)\n",
    "\telse:\n",
    "\t\t# We can't draw this directly. \n",
    "\t\traise NotImplementedError()\n",
    "\t\n",
    "\tif non_linear_axes:\n",
    "\t\t# Use pcolormesh to display\n",
    "\t\tx_mid = (x[1:] + x[:-1]) / 2\n",
    "\t\ty_mid = (y[1:] + y[:-1]) / 2\n",
    "\t\t\n",
    "\t\tx2 = np.concatenate(([1.5 * x[0] - 0.5 * x[1]], x_mid, [1.5 * x[-1] - 0.5 * x[-2]]))\n",
    "\t\ty2 = np.concatenate(([1.5 * y[0] - 0.5 * y[1]], y_mid, [1.5 * y[-1] - 0.5 * y[-2]]))\n",
    "\t\tX, Y = np.meshgrid(x2, y2)\n",
    "\t\t\n",
    "\t\tim = ax.pcolormesh(X, Y, z, *args, norm=norm, rasterized=True, cmap=cmap, **kwargs)\n",
    "\telse:\n",
    "\t\t# Use NonUniformImage to display\n",
    "\t\tim = NonUniformImage(ax, extent=(min_x, max_x, min_y, max_y), interpolation=interpolation , norm=norm, cmap=cmap, *args, **kwargs)\n",
    "\t\tim.set_data(x, y, z)\n",
    "\n",
    "\t\tfrom matplotlib.patches import Rectangle\n",
    "\t\tpatch = Rectangle((min_x, min_y), max_x - min_x, max_y - min_y, facecolor='none')\n",
    "\t\tax.add_patch(patch)\n",
    "\t\tim.set_clip_path(patch)\n",
    "\n",
    "\t\tax.images.append(im)\n",
    "\t\n",
    "\tax.set_xlim(min_x, max_x)\n",
    "\tax.set_ylim(min_y, max_y)\n",
    "\n",
    "\tif mask is not None:\n",
    "\t\tone = np.ones(grid.size)\n",
    "\t\tcol = mpl.colors.to_rgb(mask_color)\n",
    "\n",
    "\t\tm = np.array([one * col[0], one * col[1], one * col[2], 1 - mask / np.nanmax(mask)])\n",
    "\n",
    "\t\timshow_field(m, grid, ax=ax)\n",
    "\n",
    "\tnum_rows, num_cols = field.grid.shape\n",
    "\tdef format_coord(x, y):\n",
    "\t\tcol = int(np.round((x - min_x) / (max_x - min_x) * (num_cols - 1)))\n",
    "\t\trow = int(np.round((y - min_y) / (max_y - min_y) * (num_rows - 1)))\n",
    "\n",
    "\t\tif col >= 0 and col < num_cols and row >= 0 and row < num_rows:\n",
    "\t\t\tz = field.shaped[row, col]\n",
    "\t\t\tif np.iscomplexobj(z):\n",
    "\t\t\t\treturn 'x=%0.3g, y=%0.3g, z=%0.3g + 1j * %0.3g = %0.3g * exp(1j * %0.2f)' % (x, y, z.real, z.imag, np.abs(z), np.angle(z))\n",
    "\t\t\telse:\n",
    "\t\t\t\treturn 'x=%0.3g, y=%0.3g, z=%0.3g' % (x, y, z)\n",
    "\t\treturn 'x=%0.3g, y=%0.3g' % (x, y)\n",
    "\n",
    "\tax.format_coord = format_coord\n",
    "\n",
    "\tax._sci(im)\n",
    "\n",
    "return im"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
